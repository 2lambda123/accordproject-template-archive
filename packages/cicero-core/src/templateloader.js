/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        let info = gen[key](arg);
        let value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}

/**
 * Wrapper to make function asynchronous
 * @param {function} fn - the function to make asynchronous
 * @return {Promise<function>} a Promise to the results of the original function
 */
function _asyncToGenerator(fn) {
    return function() {
        let self = this,
            args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(
                    gen,
                    resolve,
                    reject,
                    _next,
                    _throw,
                    'next',
                    value
                );
            }
            function _throw(err) {
                asyncGeneratorStep(
                    gen,
                    resolve,
                    reject,
                    _next,
                    _throw,
                    'throw',
                    err
                );
            }
            _next(undefined);
        });
    };
}

const fs = require('fs');

const fsPath = require('path');

const slash = require('slash');

const JSZip = require('jszip');

const xregexp = require('xregexp');

const languageTagRegex = require('ietf-language-tag-regex');

const DefaultArchiveLoader = require('./loaders/defaultarchiveloader');

const FileLoader = require('@accordproject/ergo-compiler').FileLoader;

const Logger = require('@accordproject/concerto-core').Logger; // Matches 'sample.md' or 'sample_TAG.md' where TAG is an IETF language tag (BCP 47)

const IETF_REGEXP = languageTagRegex({
    exact: false
})
    .toString()
    .slice(1, -2);
const SAMPLE_FILE_REGEXP = xregexp(
    'text[/\\\\]sample(_(' + IETF_REGEXP + '))?.md$'
);

/**
 * A utility class to create templates from data sources.
 * @class
 * @private
 * @abstract
 */
class TemplateLoader extends FileLoader {
    /**
     * Create a template object from autogenerated cto contents
     * @param {*} Template - the type to construct
     * @param {String} modelTxt  - the text of the model.cto file required for the template
     * @param {String} requestStringified - the request.json stringified
     * @param {String} data - just stringified version of sample data [Can drop this].
     * @param {String} packageStringified - the package.json stringified
     * @param {String} logic - the text of the ergo.logic file
     * @param {String} templatizedGrammar - the templatized grammar we used to generate all of the related files.
     * @param {String} readme - readme file to include
     * @param {Object} [options] - JSZip options
     * @return {Promise<Template>} a Promise to the template
     */
    static fromGrammar(
        Template,
        modelTxt,
        requestStringified,
        data,
        packageStringified,
        logic,
        templatizedGrammar,
        readme,
        options
    ) {
        return _asyncToGenerator(function*() {
            const method = 'fromGrammar';

            //The first three seem to be universal and it's easier for testing purposes to hardcode them.
            let modelFiles = [
                {
                    name: '@models.accordproject.org.cicero.contract.cto',
                    content:
                        '/*\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace org.accordproject.cicero.contract\n\n/**\n * Contract Data\n * -- Describes the structure of contracts and clauses\n */\n\n/* A contract state is an asset -- The runtime state of the contract */\nasset AccordContractState identified by stateId {\n  o String stateId\n}\n\n/* A party to a contract */\nparticipant AccordParty identified by partyId {\n  o String partyId\n}\n\n/* A contract is a asset -- This contains the contract data */\nabstract asset AccordContract identified by contractId {\n  o String contractId\n  --> AccordParty[] parties optional\n}\n\n/* A clause is an asset -- This contains the clause data */\nabstract asset AccordClause identified by clauseId {\n  o String clauseId\n}\n'
                },
                {
                    name: '@models.accordproject.org.cicero.runtime.cto',
                    content:
                        '/*\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace org.accordproject.cicero.runtime\n\nimport org.accordproject.cicero.contract.AccordContract from https://models.accordproject.org/cicero/contract.cto\nimport org.accordproject.cicero.contract.AccordContractState from https://models.accordproject.org/cicero/contract.cto\nimport org.accordproject.money.MonetaryAmount from https://models.accordproject.org/money.cto\n\n/**\n * Contract API\n * -- Describes input and output of calls to a contract\'s clause\n */\n\n/* A request is a transaction */\ntransaction Request {}\n\n/* A response is a transaction */\ntransaction Response {}\n\n/* An Error is a transaction */\nabstract transaction ErrorResponse {}\n\n/* An event that represents an obligation that needs to be fulfilled */\nabstract event Obligation {\n  /* A back reference to the governing contract that emitted this obligation */\n  --> AccordContract contract\n\n  /* The party that is obligated */\n  --> Participant promisor optional // TODO make this mandatory once proper party support is in place\n\n  /* The party that receives the performance */\n  --> Participant promisee optional // TODO make this mandatory once proper party support is in place\n\n  /* The time before which the obligation is fulfilled */\n  o DateTime deadline optional\n}\n\nevent PaymentObligation extends Obligation{\n  o MonetaryAmount amount\n  o String description\n}\n\nevent NotificationObligation extends Obligation {\n  o String title\n  o String message\n}\n\n/* A payload has contract data, a request and a state */\nconcept Payload {\n  o AccordContract contract  // the contract data\n  o Request request\n  o AccordContractState state optional\n}\n\n/* If the call to a contract\'s clause succeeds, it returns a response, a list of events and a new state */\nconcept Success {\n  o Response response\n  o AccordContractState state\n  o Event[] emit\n}\n/* If the call to a contract\'s clause fails, it returns and error */ \nconcept Failure {\n  o ErrorResponse error\n}\n\n/**\n * The functional signature for a contract call is as follows:\n * clausecall : String contractName -> String clauseName -> Payload payload -> Success | Failure\n */\n'
                },
                {
                    name: '@models.accordproject.org.money.cto',
                    content:
                        '/*\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace org.accordproject.money\n\n/**\n * Represents an amount of Cryptocurrency\n */\nconcept CryptoMonetaryAmount {\n  o Double doubleValue\n  o CryptoCurrencyCode cryptoCurrencyCode\n}\n\n/**\n * Cyptocurrency codes. From https://en.wikipedia.org/wiki/List_of_cryptocurrencies\n */\nenum CryptoCurrencyCode {\n  o ADA\n  o BCH\n  o BTC\n  o DASH\n  o EOS\n  o ETC\n  o ETH\n  o LTC\n  o NEO\n  o XLM\n  o XMR\n  o XRP\n  o ZEC\n}\n\n/**\n * Represents an amount of money\n */\nconcept MonetaryAmount {\n  o Double doubleValue // convert to fixed-point?\n  o CurrencyCode currencyCode\n}\n\n/**\n * ISO 4217 codes. From https://en.wikipedia.org/wiki/ISO_4217\n * https://www.currency-iso.org/en/home/tables/table-a1.html\n */\nenum CurrencyCode {\no AED\no AFN\no ALL\no AMD\no ANG\no AOA\no ARS\no AUD\no AWG\no AZN\no BAM\no BBD\no BDT\no BGN\no BHD\no BIF\no BMD\no BND\no BOB\no BOV\no BRL\no BSD\no BTN\no BWP\no BYN\no BZD\no CAD\no CDF\no CHE\no CHF\no CHW\no CLF\no CLP\no CNY\no COP\no COU\no CRC\no CUC\no CUP\no CVE\no CZK\no DJF\no DKK\no DOP\no DZD\no EGP\no ERN\no ETB\no EUR\no FJD\no FKP\no GBP\no GEL\no GHS\no GIP\no GMD\no GNF\no GTQ\no GYD\no HKD\no HNL\no HRK\no HTG\no HUF\no IDR\no ILS\no INR\no IQD\no IRR\no ISK\no JMD\no JOD\no JPY\no KES\no KGS\no KHR\no KMF\no KPW\no KRW\no KWD\no KYD\no KZT\no LAK\no LBP\no LKR\no LRD\no LSL\no LYD\no MAD\no MDL\no MGA\no MKD\no MMK\no MNT\no MOP\no MRU\no MUR\no MVR\no MWK\no MXN\no MXV\no MYR\no MZN\no NAD\no NGN\no NIO\no NOK\no NPR\no NZD\no OMR\no PAB\no PEN\no PGK\no PHP\no PKR\no PLN\no PYG\no QAR\no RON\no RSD\no RUB\no RWF\no SAR\no SBD\no SCR\no SDG\no SEK\no SGD\no SHP\no SLL\no SOS\no SRD\no SSP\no STN\no SVC\no SYP\no SZL\no THB\no TJS\no TMT\no TND\no TOP\no TRY\no TTD\no TWD\no TZS\no UAH\no UGX\no USD\no USN\no UYI\no UYU\no UZS\no VEF\no VND\no VUV\no WST\no XAF\no XAG\no XAU\no XBA\no XBB\no XBC\no XBD\no XCD\no XDR\no XOF\no XPD\no XPF\no XPT\no XSU\no XTS\no XUA\no XXX\no YER\no ZAR\no ZMW\no ZWL\n}\n'
                },
                {
                    name: 'model.cto',
                    content: modelTxt
                }
            ];

            const ctoModelFiles = [];
            const ctoModelFileNames = [];
            const sampleTextFiles = {};

            modelFiles.forEach(
                /*#__PURE__*/
                (function() {
                    var _ref2 = _asyncToGenerator(function*(file) {
                        ctoModelFileNames.push(file.name);
                        ctoModelFiles.push(file.content);
                    });

                    return function(_x2) {
                        return _ref2.apply(this, arguments);
                    };
                })()
            ); // create the template

            const template = new (Function.prototype.bind.call(
                Template,
                null,
                packageStringified,
                readme,
                sampleTextFiles,
                requestStringified,
                options
            ))(); // add model files

            Logger.debug(method, 'Adding model files to model manager');
            template
                .getModelManager()
                .addModelFiles(ctoModelFiles, ctoModelFileNames, true); // validation is disabled
            Logger.debug(method, 'Setting grammar');

            if (!templatizedGrammar) {
                throw new Error(
                    'A template must contain a grammar.tem.md file.'
                );
            } else {
                template.parserManager.buildGrammar(templatizedGrammar);
            } // load and add the ergo files
            console.log('Done with templatizing');

            if (template.getMetadata().getRuntime() === 'ergo') {
                template
                    .getLogicManager()
                    .addTemplateFile(templatizedGrammar, 'text/grammar.tem.md');
                template
                    .getLogicManager()
                    .addLogicFile(logic, 'logic/logic.ergo');
            } else {
                Logger.debug(method, 'Only ERGO is supported in fromGrammar()');
            } // check the integrity of the model and logic of the template

            template.validate();
            return template; // Returns template
        })();
    }
    /**
     * Create a template from an archive.
     * @param {*} Template - the type to construct
     * @param {Buffer} buffer  - the buffer to a Cicero Template Archive (cta) file
     * @param {object} options - additional options
     * @return {Promise<Template>} a Promise to the template
     */
    static async fromArchive(Template, buffer, options) {
        const method = 'fromArchive';
        const zip = await JSZip.loadAsync(buffer);
        // const allFiles = await TemplateLoader.loadZipFilesContents(zip, /.*/);
        // console.log(allFiles);
        const ctoModelFiles = [];
        const ctoModelFileNames = [];
        const sampleTextFiles = {};

        const readmeContents = await TemplateLoader.loadZipFileContents(
            zip,
            'README.md'
        );
        let sampleFiles = await TemplateLoader.loadZipFilesContents(
            zip,
            SAMPLE_FILE_REGEXP
        );
        sampleFiles.forEach(async sampleFile => {
            let matches = sampleFile.name.match(SAMPLE_FILE_REGEXP);
            let locale = 'default';
            // Locale match found
            if (matches !== null && matches[2]) {
                locale = matches[2];
            }
            sampleTextFiles[locale] = sampleFile.contents;
        });

        const requestContents = await TemplateLoader.loadZipFileContents(
            zip,
            'request.json',
            true
        );
        const packageJsonObject = await TemplateLoader.loadZipFileContents(
            zip,
            'package.json',
            true,
            true
        );
        const templatizedGrammar = await TemplateLoader.loadZipFileContents(
            zip,
            'text/grammar.tem.md',
            false,
            false
        );

        Logger.debug(method, 'Looking for model files');
        let ctoFiles = await TemplateLoader.loadZipFilesContents(
            zip,
            /model[/\\].*\.cto$/
        );
        ctoFiles.forEach(async file => {
            ctoModelFileNames.push(file.name);
            ctoModelFiles.push(file.contents);
        });

        // create the template
        const template = new (Function.prototype.bind.call(
            Template,
            null,
            packageJsonObject,
            readmeContents,
            sampleTextFiles,
            requestContents,
            options
        ))();

        // add model files
        Logger.debug(method, 'Adding model files to model manager');
        template
            .getModelManager()
            .addModelFiles(ctoModelFiles, ctoModelFileNames, true); // validation is disabled

        Logger.debug(method, 'Setting grammar');
        if (!templatizedGrammar) {
            throw new Error('A template must contain a grammar.tem.md file.');
        } else {
            template.parserManager.buildGrammar(templatizedGrammar);
        }

        // load and add the ergo files
        if (template.getMetadata().getRuntime() === 'ergo') {
            template
                .getLogicManager()
                .addTemplateFile(templatizedGrammar, 'text/grammar.tem.md');
            Logger.debug(method, 'Adding Ergo files to script manager');
            const scriptFiles = await TemplateLoader.loadZipFilesContents(
                zip,
                /logic[/\\].*\.ergo$/
            );
            scriptFiles.forEach(function(obj) {
                template.getLogicManager().addLogicFile(obj.contents, obj.name);
            });
        } else {
            // load and add compiled JS files - we assume all runtimes are JS based (review!)
            Logger.debug(method, 'Adding JS files to script manager');
            const scriptFiles = await TemplateLoader.loadZipFilesContents(
                zip,
                /logic[/\\].*\.js$/
            );
            scriptFiles.forEach(function(obj) {
                template.getLogicManager().addLogicFile(obj.contents, obj.name);
            });
        }

        // check the integrity of the model and logic of the template
        template.validate();

        return template; // Returns template
    }

    /**
     * Create a template from an URL.
     * @param {*} Template - the type to construct
     * @param {String} url  - the URL to a Cicero Template Archive (cta) file
     * @param {object} options - additional options
     * @return {Promise} a Promise to the template
     */
    static fromUrl(Template, url, options) {
        return _asyncToGenerator(function*() {
            const loader = new DefaultArchiveLoader();
            const buffer = yield loader.load(url, options);
            return TemplateLoader.fromArchive(Template, buffer, options);
        })();
    }

    /**
     * Builds a Template from the contents of a directory.
     * The directory must include a package.json in the root (used to specify
     * the name, version and description of the template).
     *
     * @param {*} Template - the type to construct
     * @param {String} path to a local directory
     * @param {Object} [options] - an optional set of options to configure the instance.
     * @return {Promise<Template>} a Promise to the instantiated template
     */
    static fromDirectory(Template, path, options) {
        return _asyncToGenerator(function*() {
            if (!options) {
                options = {};
            }

            const method = 'fromDirectory'; // grab the README.md

            const readmeContents = yield TemplateLoader.loadFileContents(
                path,
                'README.md'
            ); // grab the request.json

            const requestJsonObject = yield TemplateLoader.loadFileContents(
                path,
                'request.json',
                true
            ); // grab the package.json

            const packageJsonObject = yield TemplateLoader.loadFileContents(
                path,
                'package.json',
                true,
                true
            ); // grab the sample files

            Logger.debug(method, 'Looking for sample files');
            const sampleFiles = yield TemplateLoader.loadFilesContents(
                path,
                SAMPLE_FILE_REGEXP
            );
            const sampleTextFiles = {};
            sampleFiles.forEach(file => {
                const matches = file.name.match(SAMPLE_FILE_REGEXP);
                let locale = 'default'; // Match found

                if (matches !== null && matches[2]) {
                    locale = matches[2];
                }

                Logger.debug(method, 'Using sample file locale', locale);
                sampleTextFiles[locale] = file.contents;
            }); // create the template

            const template = new (Function.prototype.bind.call(
                Template,
                null,
                packageJsonObject,
                readmeContents,
                sampleTextFiles,
                requestJsonObject,
                options
            ))();
            const modelFiles = [];
            const modelFileNames = [];
            const ctoFiles = yield TemplateLoader.loadFilesContents(
                path,
                /model[/\\].*\.cto$/
            );
            ctoFiles.forEach(file => {
                modelFileNames.push(slash(file.name));
                modelFiles.push(file.contents);
            });
            template
                .getModelManager()
                .addModelFiles(modelFiles, modelFileNames, true);

            if (!options.skipUpdateExternalModels) {
                yield template.getModelManager().updateExternalModels();
                Logger.debug(method, 'Added model files', modelFiles.length);
                const externalModelFiles = template
                    .getModelManager()
                    .getModels();
                externalModelFiles.forEach(function(file) {
                    fs.writeFileSync(
                        path + '/model/' + file.name,
                        file.content
                    );
                });
            } // load and add the template

            let templatizedGrammar = yield TemplateLoader.loadFileContents(
                path,
                'text/grammar.tem.md',
                false,
                false
            );

            if (!templatizedGrammar) {
                throw new Error(
                    'A template must either contain a grammar.tem.md file.'
                );
            } else {
                template.parserManager.buildGrammar(templatizedGrammar);
                Logger.debug(
                    method,
                    'Loaded grammar.tem.md',
                    templatizedGrammar
                );
            }

            Logger.debug(method, 'Loaded grammar.tem.md'); // load and add the ergo files

            if (template.getMetadata().getRuntime() === 'ergo') {
                // If Ergo then also register the template
                template
                    .getLogicManager()
                    .addTemplateFile(templatizedGrammar, 'text/grammar.tem.md');
                const ergoFiles = yield TemplateLoader.loadFilesContents(
                    path,
                    /logic[/\\].*\.ergo$/
                );
                ergoFiles.forEach(file => {
                    const resolvedPath = slash(fsPath.resolve(path));
                    const resolvedFilePath = slash(fsPath.resolve(file.name));
                    const truncatedPath = resolvedFilePath.replace(
                        resolvedPath + '/',
                        ''
                    );
                    template
                        .getLogicManager()
                        .addLogicFile(file.contents, truncatedPath);
                });
            } else {
                // load and add compiled JS files - we assume all runtimes are JS based (review!)
                const jsFiles = yield TemplateLoader.loadFilesContents(
                    path,
                    /logic[/\\].*\.js$/
                );
                jsFiles.forEach(file => {
                    const resolvedPath = slash(fsPath.resolve(path));
                    const resolvedFilePath = slash(fsPath.resolve(file.name));
                    const truncatedPath = resolvedFilePath.replace(
                        resolvedPath + '/',
                        ''
                    );
                    template
                        .getLogicManager()
                        .addLogicFile(file.contents, truncatedPath);
                });
            } // check the template

            template.validate();
            return template;
        })();
    }

    /**
     * Prepare the text for parsing (normalizes new lines, etc)
     * @param {string} input - the text for the clause
     * @return {string} - the normalized text for the clause
     */
    static normalizeText(input) {
        // we replace all \r and \n with \n
        let text = input.replace(/\r/gm, '');
        return text;
    }
}

module.exports = TemplateLoader;
